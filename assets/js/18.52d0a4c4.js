(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{433:function(t,e,v){"use strict";v.r(e);var a=v(62),_=Object(a.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("p",[v("strong",[t._v("既然是事件委托")])]),t._v(" "),v("h1",{attrs:{id:"react-事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#react-事件"}},[t._v("#")]),t._v(" "),v("RouterLink",{attrs:{to:"/React/React 原理/#事件绑定-事件初始化"}},[t._v("React 事件 ")])],1),t._v(" "),v("h1",{attrs:{id:"先解释事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#先解释事件"}},[t._v("#")]),t._v(" 先解释事件：")]),t._v(" "),v("p",[v("strong",[t._v("事件")]),t._v("  是某事发生的信号。所有的 DOM 节点都生成这样的信号（但事件不仅限于 DOM）。")]),t._v(" "),v("p",[t._v("包括鼠标事件，键盘事件，表单元素事件，css 事件等。")]),t._v(" "),v("h3",{attrs:{id:"事件对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事件对象"}},[t._v("#")]),t._v(" 事件对象")]),t._v(" "),v("p",[v("strong",[t._v("浏览器会在事件发生的时候创建一个事件对象"),v("code",[t._v("event")]),t._v("，作为参数传入给处理函数")])]),t._v(" "),v("p",[t._v("事件对象的属性")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("event.type")]),t._v("事件类型")]),t._v(" "),v("li",[v("code",[t._v("event.currentTarget")]),t._v("处理事件的元素。")]),t._v(" "),v("li",[v("code",[t._v("event.clientX / event.clientY")]),t._v("指针事件（pointer event）的指针的窗口相对坐标。")])]),t._v(" "),v("h1",{attrs:{id:"再解释冒泡和捕获"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#再解释冒泡和捕获"}},[t._v("#")]),t._v(" 再解释冒泡和捕获")]),t._v(" "),v("h2",{attrs:{id:"冒泡"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#冒泡"}},[t._v("#")]),t._v(" 冒泡")]),t._v(" "),v("p",[t._v("冒泡的原理很简单")]),t._v(" "),v("p",[v("strong",[t._v("当一个事件发生在元素上，首先会执行当前元素上处理程序，然后执行他的父级元素上的处理程序，然后执行祖先上的处理程序")])]),t._v(" "),v("p",[t._v("这个过程就是冒泡")]),t._v(" "),v("h2",{attrs:{id:"event-target"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#event-target"}},[t._v("#")]),t._v(" event.target")]),t._v(" "),v("p",[t._v("父元素上的处理程序始终可以获取事件实际发生位置的详细信息。")]),t._v(" "),v("p",[v("strong",[t._v("引发事件的那个嵌套层级最深的元素被称为目标元素,可以通过  "),v("code",[t._v("event.target")]),t._v("  访问。")])]),t._v(" "),v("p",[t._v("要注意的是 this 和 event.target 不是同一个东西")]),t._v(" "),v("p",[t._v("this 指的是当前的元素，event.target 不会改变，始终是引发事件的元素")]),t._v(" "),v("h2",{attrs:{id:"捕获"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#捕获"}},[t._v("#")]),t._v(" 捕获")]),t._v(" "),v("p",[t._v("事件处理的另一个阶段就是捕获")]),t._v(" "),v("p",[v("a",{attrs:{href:"http://www.w3.org/TR/DOM-Level-3-Events/",target:"_blank",rel:"noopener noreferrer"}},[t._v("DOM 事件"),v("OutboundLink")],1),t._v("标准描述了事件传播的 3 个阶段：")]),t._v(" "),v("ol",[v("li",[t._v("捕获阶段（Capturing phase）—— 事件（从 Window）向下走近元素。")]),t._v(" "),v("li",[t._v("目标阶段（Target phase）—— 事件到达目标元素。")]),t._v(" "),v("li",[t._v("冒泡阶段（Bubbling phase）—— 事件从元素上开始冒泡。")])]),t._v(" "),v("p",[t._v("那么怎么做到事件捕获的？")]),t._v(" "),v("p",[t._v("我们需要将处理程序的  "),v("code",[t._v("capture")]),t._v("  选项设置为  "),v("code",[t._v("true")])]),t._v(" "),v("div",{staticClass:"language-js extra-class"},[v("pre",{pre:!0,attrs:{class:"language-js"}},[v("code",[t._v("elem"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("addEventListener")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),v("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("capture")]),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// 或者，用 {capture: true} 的别名 "true"')]),t._v("\nelem"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("addEventListener")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),v("p",[v("code",[t._v("capture")]),t._v("  选项有两个可能的值：")]),t._v(" "),v("ul",[v("li",[t._v("如果为  "),v("code",[t._v("false")]),t._v("（默认值），则在冒泡阶段设置处理程序。")]),t._v(" "),v("li",[t._v("如果为  "),v("code",[t._v("true")]),t._v("，则在捕获阶段设置处理程序。")])]),t._v(" "),v("h2",{attrs:{id:"小总结一下"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#小总结一下"}},[t._v("#")]),t._v(" 小总结一下")]),t._v(" "),v("p",[t._v("当一个事件发生的时候，事件发生最深的元素被标记为“目标对象”"),v("code",[t._v("event.target")])]),t._v(" "),v("ul",[v("li",[t._v("事件从文档根节点向下移动到目标对象，期间执行捕获（"),v("code",[t._v("elem.addEventListener(..., true)")]),t._v("）的处理程序")]),t._v(" "),v("li",[t._v("触发目标元素的处理程序")]),t._v(" "),v("li",[t._v("然后冒泡到根，调用使用  "),v("code",[t._v("on<event>")]),t._v("、HTML 特性（attribute）和没有第三个参数的，或者第三个参数为  "),v("code",[t._v("false/{capture:false}")]),t._v("  的  "),v("code",[t._v("addEventListener")]),t._v("  分配的处理程序。")])]),t._v(" "),v("p",[t._v("每个处理程序都可以访问 event")]),t._v(" "),v("ul",[v("li",[t._v("event.target——事件发生的最深元素")]),t._v(" "),v("li",[t._v("event.currentTarget ——事件发生的当前元素")]),t._v(" "),v("li",[t._v("event.eventPhase——事件发生的阶段")])]),t._v(" "),v("h1",{attrs:{id:"事件委托"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事件委托"}},[t._v("#")]),t._v(" 事件委托")]),t._v(" "),v("p",[t._v("事件捕获和冒泡可以让我们实现事件委托")]),t._v(" "),v("p",[t._v("这个想法是，如果我们有许多以类似方式处理的元素，那么就不必为每个元素分配一个处理程序 —— 而是将单个处理程序放在它们的共同祖先上。")]),t._v(" "),v("p",[t._v("在处理程序中，我们获取  "),v("code",[t._v("event.target")]),t._v("  以查看事件实际发生的位置并进行处理。")]),t._v(" "),v("p",[t._v("这些大家都知道或者百度下示例。。。")]),t._v(" "),v("h2",{attrs:{id:"事件委托还有其他用途。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事件委托还有其他用途。"}},[t._v("#")]),t._v(" 事件委托还有其他用途。")]),t._v(" "),v("p",[t._v("例如，我们想要编写一个有“保存”、“加载”和“搜索”等按钮的菜单。并且，这里有一个具有  "),v("code",[t._v("save")]),t._v("、"),v("code",[t._v("load")]),t._v("  和  "),v("code",[t._v("search")]),t._v("  等方法的对象。如何匹配它们？")]),t._v(" "),v("p",[t._v("第一个想法可能是为每个按钮分配一个单独的处理程序。但是有一个更优雅的解决方案。我们可以为整个菜单添加一个处理程序，并为具有方法调用的按钮添加  "),v("code",[t._v("data-action")]),t._v("  特性（attribute）：")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://pub-a953275fa2c34c18b80fc1f84e3ea746.r2.dev/xiaowo/2023/08/71176f7efaaaf87fc9349ba3c6a769d9.png",alt:""}})]),t._v(" "),v("h2",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),v("p",[t._v("事件委托非常的普遍，这是 DOM 事件最有用的模式之一。")]),t._v(" "),v("p",[t._v("它通常用于为许多相似的元素添加相同的处理，但不仅限于此。")]),t._v(" "),v("p",[t._v("算法：")]),t._v(" "),v("ol",[v("li",[t._v("在容器（container）上放一个处理程序。")]),t._v(" "),v("li",[t._v("在处理程序中 —— 检查源元素  "),v("code",[t._v("event.target")]),t._v("。")]),t._v(" "),v("li",[t._v("如果事件发生在我们感兴趣的元素内，那么处理该事件。")])]),t._v(" "),v("p",[t._v("好处：")]),t._v(" "),v("ul",[v("li",[t._v("简化初始化并节省内存：无需添加许多处理程序。")]),t._v(" "),v("li",[t._v("更少的代码：添加或移除元素时，无需添加/移除处理程序。")]),t._v(" "),v("li",[t._v("DOM 修改 ：我们可以使用  "),v("code",[t._v("innerHTML")]),t._v("  等，来批量添加/移除元素。")])]),t._v(" "),v("p",[t._v("事件委托也有其局限性：")]),t._v(" "),v("ul",[v("li",[t._v("首先，事件必须冒泡。而有些事件不会冒泡。此外，低级别的处理程序不应该使用  "),v("code",[t._v("event.stopPropagation()")]),t._v("。")]),t._v(" "),v("li",[t._v("其次，委托可能会增加 CPU 负载，因为容器级别的处理程序会对容器中任意位置的事件做出反应，而不管我们是否对该事件感兴趣。但是，通常负载可以忽略不计，所以我们不考虑它。")])])])}),[],!1,null,null,null);e.default=_.exports}}]);