(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{459:function(e,v,r){"use strict";r.r(v);var t=r(62),n=Object(t.a)({},(function(){var e=this,v=e.$createElement,r=e._self._c||v;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"总体分三步"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#总体分三步"}},[e._v("#")]),e._v(" 总体分三步")]),e._v(" "),r("ul",[r("li",[e._v("相同的前置节点和后置节点")]),e._v(" "),r("li",[e._v("判断是否需要进行 DOM 的移动")]),e._v(" "),r("li",[e._v("移动元素")])]),e._v(" "),r("h1",{attrs:{id:"第一部分-相同的前置节点和后置节点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第一部分-相同的前置节点和后置节点"}},[e._v("#")]),e._v(" 第一部分 相同的前置节点和后置节点")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://pub-a953275fa2c34c18b80fc1f84e3ea746.r2.dev/xiaowo/2023/08/dba345988e7b7a2fbabf1725228f1031.png",alt:""}})]),e._v(" "),r("ul",[r("li",[e._v("开启一个从头向尾的循环，判断 新旧节点的 key 是否相同，不相同退出")]),e._v(" "),r("li",[e._v("开启一个从尾向头的循环，判断 新旧节点的 key 是否相同，不相同退出")]),e._v(" "),r("li",[e._v("判断 新节点没有遍历完且旧节点遍历完，依次新增")]),e._v(" "),r("li",[e._v("判断 旧节点没有遍历完且新节点遍历完，依次卸载")]),e._v(" "),r("li",[e._v("判断 新节点没有遍历完且旧节点也没遍历完，则进行比较第二步部分（判断是否需要进行 DOM 的移动）")])]),e._v(" "),r("h1",{attrs:{id:"第二部分-判断是否需要进行-dom-的移动"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第二部分-判断是否需要进行-dom-的移动"}},[e._v("#")]),e._v(" 第二部分 判断是否需要进行 DOM 的移动")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://pub-a953275fa2c34c18b80fc1f84e3ea746.r2.dev/xiaowo/2023/08/3f8b536f81f222b473575cc0cf621df7.png",alt:""}})]),e._v(" "),r("ul",[r("li",[e._v("构建一个 sources 数组，用于存放，新节点对应旧节点组中的索引\n"),r("ul",[r("li",[e._v("遍历新节点组，将其 "),r("code",[e._v("el.key")]),e._v(" 作为"),r("code",[e._v("[key]")]),e._v(",index 作为 "),r("code",[e._v("[value]")]),e._v(" 保存为一个"),r("strong",[e._v("索引表")])]),e._v(" "),r("li",[e._v("遍历旧节点组，在"),r("strong",[e._v("索引表")]),e._v("中找相同的 "),r("code",[e._v("el.key")]),e._v(" "),r("ul",[r("li",[e._v("没找到，卸载节点")]),e._v(" "),r("li",[e._v("找到了，将其在旧节点中的索引 放入 索引的 "),r("code",[e._v("source")]),e._v(" 中, 和简单 diff 算法类似，判断是否有需要移动的节点")])])])])])]),e._v(" "),r("h1",{attrs:{id:"第三部分-移动元素"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第三部分-移动元素"}},[e._v("#")]),e._v(" 第三部分 移动元素")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://pub-a953275fa2c34c18b80fc1f84e3ea746.r2.dev/xiaowo/2023/08/e6f592d4bc4f6a557358527659a7db3d.png",alt:""}})]),e._v(" "),r("ul",[r("li",[e._v("通过 "),r("code",[e._v("source")]),e._v(" 计算出"),r("strong",[e._v("最长递增子序列")]),e._v(" "),r("code",[e._v("seq")]),e._v("数组，表示最长递增子序列在"),r("code",[e._v("source")]),e._v("中的索引")])]),e._v(" "),r("blockquote",[r("p",[e._v("最长递增子序列说明 这些节点的位置没有发生改变，可以不需要移动")])]),e._v(" "),r("ul",[r("li",[r("code",[e._v("i")]),e._v(" 指向新的一组节点中的最后一个元素，· 指向最长递增子序列中的最后一个元素，循环使 "),r("code",[e._v("i")]),e._v(" 递减，从下向上移动\n"),r("ul",[r("li",[e._v("判断 "),r("code",[e._v("i")]),e._v(" 是不是 -1 （-1 说明在节点中没有找到该新节点的位置），新增节点")]),e._v(" "),r("li",[e._v("判断 "),r("code",[e._v("i")]),e._v(" 和 "),r("code",[e._v("seq[s]")]),e._v(" 不相等（说明该节点需要移动）\n"),r("ul",[r("li",[e._v("找到该节点在新节点组中的真实位置作为锚点")]),e._v(" "),r("li",[e._v("移动")])])]),e._v(" "),r("li",[e._v("判断 "),r("code",[e._v("i")]),e._v(" 和 "),r("code",[e._v("seq[s]")]),e._v(" 相等，说明该节点不需要移动\n"),r("ul",[r("li",[r("code",[e._v("s--")]),e._v(" 向上继续")])])])])])]),e._v(" "),r("blockquote",[r("p",[e._v("最长递增子序列")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("function getSequence(arr) {\n  const p = arr.slice(); //  保存原始数据\n  const result = [0]; //  存储最长增长子序列的索引数组\n  let i, j, u, v, c;\n  const len = arr.length;\n  for (i = 0; i < len; i++) {\n    const arrI = arr[i];\n    if (arrI !== 0) {\n      j = result[result.length - 1]; //  j是子序列索引最后一项\n      if (arr[j] < arrI) {\n        //  如果arr[i] > arr[j], 当前值比最后一项还大，可以直接push到索引数组(result)中去\n        p[i] = j; //  p记录第i个位置的索引变为j\n        result.push(i);\n        continue;\n      }\n      u = 0; //  数组的第一项\n      v = result.length - 1; //  数组的最后一项\n      while (u < v) {\n        //  如果arrI <= arr[j] 通过二分查找，将i插入到result对应位置；u和v相等时循环停止\n        c = ((u + v) / 2) | 0; //  二分查找\n        if (arr[result[c]] < arrI) {\n          u = c + 1; //  移动u\n        } else {\n          v = c; //  中间的位置大于等于i,v=c\n        }\n      }\n      if (arrI < arr[result[u]]) {\n        if (u > 0) {\n          p[i] = result[u - 1]; //  记录修改的索引\n        }\n        result[u] = i; //  更新索引数组(result)\n      }\n    }\n  }\n  u = result.length;\n  v = result[u - 1];\n  //把u值赋给result\n  while (u-- > 0) {\n    //  最后通过p数组对result数组进行进行修订，取得正确的索引\n    result[u] = v;\n    v = p[v];\n  }\n  return result;\n}\n\n\n\n")])])])])}),[],!1,null,null,null);v.default=n.exports}}]);