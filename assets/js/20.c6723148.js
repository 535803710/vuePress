(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{435:function(n,t,a){"use strict";a.r(t);var e=a(62),r=Object(e.a)({},(function(){var n=this,t=n.$createElement,a=n._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h1",{attrs:{id:"执行上下文和堆栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文和堆栈"}},[n._v("#")]),n._v(" 执行上下文和堆栈")]),n._v(" "),a("p",[n._v("现在我们来研究一下递归调用是如何工作的。为此，我们会先看看函数底层的工作原理。")]),n._v(" "),a("p",[n._v("有关正在运行的函数的执行过程的相关信息被存储在其 "),a("strong",[n._v("执行上下文")]),n._v(" 中。")]),n._v(" "),a("p",[a("a",{attrs:{href:"https://tc39.github.io/ecma262/#sec-execution-contexts",target:"_blank",rel:"noopener noreferrer"}},[n._v("执行上下文"),a("OutboundLink")],1),n._v(" 是一个内部数据结构，它包含有关函数执行时的详细细节：当前控制流所在的位置，当前的变量，this 的值（此处我们不使用它），以及其它的一些内部细节。")]),n._v(" "),a("p",[n._v("一个函数调用仅具有一个与其相关联的执行上下文。")]),n._v(" "),a("p",[n._v("当一个函数进行嵌套调用时，将发生以下的事儿：")]),n._v(" "),a("ul",[a("li",[n._v("当前函数被暂停；")]),n._v(" "),a("li",[n._v("与它关联的执行上下文被一个叫做 执行上下文堆栈 的特殊数据结构保存；")]),n._v(" "),a("li",[n._v("执行嵌套调用；")]),n._v(" "),a("li",[n._v("嵌套调用结束后，从堆栈中恢复之前的执行上下文，并从停止的位置恢复外部函数。")])]),n._v(" "),a("h1",{attrs:{id:"尾调用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#尾调用"}},[n._v("#")]),n._v(" 尾调用")]),n._v(" "),a("blockquote",[a("p",[n._v("尾调用指的是函数的返回另一个函数的调用")])]),n._v(" "),a("h1",{attrs:{id:"尾递归"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#尾递归"}},[n._v("#")]),n._v(" 尾递归")]),n._v(" "),a("blockquote",[a("p",[n._v("函数尾调用自身，就是尾递归")])]),n._v(" "),a("p",[n._v("下面代码就是尾递归")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function pow(x, n) {\n  if (n == 1) {\n    return x;\n  } else {\n    return x * pow(x, n - 1);\n  }\n}\n\nalert( pow(2, 3) );\n\n")])])]),a("p",[a("strong",[n._v("任何递归都可以用循环来重写。通常循环变体更有效。")])]),n._v(" "),a("p",[n._v("……但有时重写很难，尤其是函数根据条件使用不同的子调用，然后合并它们的结果，或者分支比较复杂时。而且有些优化可能没有必要，完全不值得。")]),n._v(" "),a("p",[n._v("递归可以使代码更短，更易于理解和维护。并不是每个地方都需要优化，大多数时候我们需要一个好代码，这就是为什么要使用它。")]),n._v(" "),a("h1",{attrs:{id:"尾递归优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#尾递归优化"}},[n._v("#")]),n._v(" 尾递归优化")]),n._v(" "),a("h2",{attrs:{id:"蹦床函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#蹦床函数"}},[n._v("#")]),n._v(" 蹦床函数")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function trampoline(f) {\n  while (f && typeof f === 'function') {\n    f = f()\n  }\n  return f\n}\n\nfunction f(n, m = 1, o = 1) {\n  if (n <= 2) {\n    return o\n  }\n  return f.bind(null, n - 1, o, m + o)\n}\n\ntrampoline(f(40)) // 102334155\ntrampoline(f(100000)) // Infinity\n")])])]),a("h2",{attrs:{id:"深度遍历算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#深度遍历算法"}},[n._v("#")]),n._v(" 深度遍历算法")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function tco(func) {\n  var value\n  var active = false\n  const accumulated = []\n\n  return function accumulator(...args) {\n    accumulated.push(args)\n\n    if (!active) {\n      active = true\n      while (accumulated.length) {\n        value = func.apply(this, accumulated.shift())\n      }\n      active = false\n\n      return value\n    }\n  }\n}\n\nconst f = tco(function fibonacci(n, m = 1, o = 1) {\n  if (n <= 2) {\n    return o\n  }\n  return f(n - 1, o, m + o)\n})\n\nf(40) // 102334155\nf(100000) // Infinity\n\n")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);