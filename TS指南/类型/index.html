<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>类型 | 前端小蜗</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/vuepress/img/home.jpeg">
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/vuepress/assets/css/0.styles.189cad16.css" as="style"><link rel="preload" href="/vuepress/assets/js/app.40312837.js" as="script"><link rel="preload" href="/vuepress/assets/js/2.cf1e524c.js" as="script"><link rel="preload" href="/vuepress/assets/js/37.e955d687.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/10.a610a9ba.js"><link rel="prefetch" href="/vuepress/assets/js/11.f87d06bd.js"><link rel="prefetch" href="/vuepress/assets/js/12.11a58652.js"><link rel="prefetch" href="/vuepress/assets/js/13.110f8559.js"><link rel="prefetch" href="/vuepress/assets/js/14.322c46a5.js"><link rel="prefetch" href="/vuepress/assets/js/15.b2b443b5.js"><link rel="prefetch" href="/vuepress/assets/js/16.7ff17cba.js"><link rel="prefetch" href="/vuepress/assets/js/17.fc193e79.js"><link rel="prefetch" href="/vuepress/assets/js/18.52d0a4c4.js"><link rel="prefetch" href="/vuepress/assets/js/19.25f2d672.js"><link rel="prefetch" href="/vuepress/assets/js/20.c6723148.js"><link rel="prefetch" href="/vuepress/assets/js/21.74e5c0f6.js"><link rel="prefetch" href="/vuepress/assets/js/22.e6d1a64a.js"><link rel="prefetch" href="/vuepress/assets/js/23.86aba3c2.js"><link rel="prefetch" href="/vuepress/assets/js/24.3ae19470.js"><link rel="prefetch" href="/vuepress/assets/js/25.edcf91c9.js"><link rel="prefetch" href="/vuepress/assets/js/26.89319ef2.js"><link rel="prefetch" href="/vuepress/assets/js/27.9e533376.js"><link rel="prefetch" href="/vuepress/assets/js/28.93a6ba41.js"><link rel="prefetch" href="/vuepress/assets/js/29.d72f0022.js"><link rel="prefetch" href="/vuepress/assets/js/3.a5adedeb.js"><link rel="prefetch" href="/vuepress/assets/js/30.871cc77c.js"><link rel="prefetch" href="/vuepress/assets/js/31.11915659.js"><link rel="prefetch" href="/vuepress/assets/js/32.2d371a40.js"><link rel="prefetch" href="/vuepress/assets/js/33.19d049e9.js"><link rel="prefetch" href="/vuepress/assets/js/34.52633d55.js"><link rel="prefetch" href="/vuepress/assets/js/35.c77625e0.js"><link rel="prefetch" href="/vuepress/assets/js/36.ec517178.js"><link rel="prefetch" href="/vuepress/assets/js/38.a76e9c38.js"><link rel="prefetch" href="/vuepress/assets/js/39.0758c6eb.js"><link rel="prefetch" href="/vuepress/assets/js/4.7fc56b7b.js"><link rel="prefetch" href="/vuepress/assets/js/40.bfc21b26.js"><link rel="prefetch" href="/vuepress/assets/js/41.1cca45c8.js"><link rel="prefetch" href="/vuepress/assets/js/42.76b92fb2.js"><link rel="prefetch" href="/vuepress/assets/js/43.5bcb4c47.js"><link rel="prefetch" href="/vuepress/assets/js/44.0bf86704.js"><link rel="prefetch" href="/vuepress/assets/js/45.b6f1d2ae.js"><link rel="prefetch" href="/vuepress/assets/js/46.d942ba15.js"><link rel="prefetch" href="/vuepress/assets/js/47.8bb95ad0.js"><link rel="prefetch" href="/vuepress/assets/js/48.fb8ad7c2.js"><link rel="prefetch" href="/vuepress/assets/js/49.fb46b14b.js"><link rel="prefetch" href="/vuepress/assets/js/5.6ac62750.js"><link rel="prefetch" href="/vuepress/assets/js/50.49f08253.js"><link rel="prefetch" href="/vuepress/assets/js/51.7663b0cd.js"><link rel="prefetch" href="/vuepress/assets/js/52.90d8fc5a.js"><link rel="prefetch" href="/vuepress/assets/js/53.00bdcc76.js"><link rel="prefetch" href="/vuepress/assets/js/54.93e18111.js"><link rel="prefetch" href="/vuepress/assets/js/55.c887fc69.js"><link rel="prefetch" href="/vuepress/assets/js/56.0f6408ae.js"><link rel="prefetch" href="/vuepress/assets/js/57.e8334a13.js"><link rel="prefetch" href="/vuepress/assets/js/58.52393270.js"><link rel="prefetch" href="/vuepress/assets/js/59.d0661709.js"><link rel="prefetch" href="/vuepress/assets/js/6.d831054f.js"><link rel="prefetch" href="/vuepress/assets/js/60.0b34950f.js"><link rel="prefetch" href="/vuepress/assets/js/61.13e9f684.js"><link rel="prefetch" href="/vuepress/assets/js/62.caee8c5c.js"><link rel="prefetch" href="/vuepress/assets/js/63.a22fbd8d.js"><link rel="prefetch" href="/vuepress/assets/js/64.d8204a06.js"><link rel="prefetch" href="/vuepress/assets/js/65.4d094f10.js"><link rel="prefetch" href="/vuepress/assets/js/66.b4582d16.js"><link rel="prefetch" href="/vuepress/assets/js/67.93aa23db.js"><link rel="prefetch" href="/vuepress/assets/js/68.b57ddd04.js"><link rel="prefetch" href="/vuepress/assets/js/69.83923766.js"><link rel="prefetch" href="/vuepress/assets/js/7.b60f99e7.js"><link rel="prefetch" href="/vuepress/assets/js/70.39d4195c.js"><link rel="prefetch" href="/vuepress/assets/js/71.e28be685.js"><link rel="prefetch" href="/vuepress/assets/js/72.e068c5cc.js"><link rel="prefetch" href="/vuepress/assets/js/73.3c5972cf.js"><link rel="prefetch" href="/vuepress/assets/js/74.2c300814.js"><link rel="prefetch" href="/vuepress/assets/js/75.16887871.js"><link rel="prefetch" href="/vuepress/assets/js/76.aef8e41e.js"><link rel="prefetch" href="/vuepress/assets/js/77.11355457.js"><link rel="prefetch" href="/vuepress/assets/js/78.d6a93a91.js"><link rel="prefetch" href="/vuepress/assets/js/79.394993f0.js"><link rel="prefetch" href="/vuepress/assets/js/8.affe4fa6.js"><link rel="prefetch" href="/vuepress/assets/js/80.60f3a775.js"><link rel="prefetch" href="/vuepress/assets/js/81.25fbce38.js"><link rel="prefetch" href="/vuepress/assets/js/82.beae6628.js"><link rel="prefetch" href="/vuepress/assets/js/83.3bd6257a.js"><link rel="prefetch" href="/vuepress/assets/js/84.851ad369.js"><link rel="prefetch" href="/vuepress/assets/js/85.8ddf405f.js"><link rel="prefetch" href="/vuepress/assets/js/86.8fcd8b07.js"><link rel="prefetch" href="/vuepress/assets/js/87.5d4b02bf.js"><link rel="prefetch" href="/vuepress/assets/js/88.e523ea38.js"><link rel="prefetch" href="/vuepress/assets/js/89.89ebef39.js"><link rel="prefetch" href="/vuepress/assets/js/9.a4881f71.js">
    <link rel="stylesheet" href="/vuepress/assets/css/0.styles.189cad16.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vuepress/" class="home-link router-link-active"><img src="/vuepress/img/home.jpeg" alt="前端小蜗" class="logo"> <span class="site-name can-hide">前端小蜗</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vuepress/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/vuepress/guide/" class="nav-link">
  指南
</a></div><div class="nav-item"><a href="https://f2e.tech/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  前端学习路径
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://roadmap.sh/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  学习路线图
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://juejin.cn/user/61995432544503" target="_blank" rel="noopener noreferrer" class="nav-link external">
  我的其他文章
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/vuepress/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/vuepress/guide/" class="nav-link">
  指南
</a></div><div class="nav-item"><a href="https://f2e.tech/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  前端学习路径
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://roadmap.sh/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  学习路线图
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://juejin.cn/user/61995432544503" target="_blank" rel="noopener noreferrer" class="nav-link external">
  我的其他文章
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/vuepress/guide/" class="sidebar-link">介绍</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/vuepress/JS基础/" class="sidebar-heading clickable"><span>JS基础</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/vuepress/小程序/" class="sidebar-heading clickable"><span>小程序</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/vuepress/浏览器/" class="sidebar-heading clickable"><span>浏览器</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/vuepress/HTTP/" class="sidebar-heading clickable"><span>HTTP</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/vuepress/Node/拦截器/" class="sidebar-heading clickable"><span>Node</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/vuepress/Vue/vue" class="sidebar-heading clickable"><span>Vue</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/vuepress/React/" class="sidebar-heading clickable"><span>React</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/vuepress/算法/常见算法/" class="sidebar-heading clickable"><span>算法</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/vuepress/工程体系/" class="sidebar-heading clickable"><span>前端工程化</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/vuepress/最佳实践/" class="sidebar-heading clickable"><span>最佳实践</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/vuepress/TS指南/" class="sidebar-heading clickable open"><span>TypeScrpit</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/vuepress/TS%E6%8C%87%E5%8D%97/%E7%B1%BB%E5%9E%8B/" aria-current="page" class="active sidebar-link">类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vuepress/TS%E6%8C%87%E5%8D%97/%E7%B1%BB%E5%9E%8B/#原始类型" class="sidebar-link">原始类型</a></li><li class="sidebar-sub-header"><a href="/vuepress/TS%E6%8C%87%E5%8D%97/%E7%B1%BB%E5%9E%8B/#数组的类型标注" class="sidebar-link">数组的类型标注</a></li><li class="sidebar-sub-header"><a href="/vuepress/TS%E6%8C%87%E5%8D%97/%E7%B1%BB%E5%9E%8B/#对象的类型标注" class="sidebar-link">对象的类型标注</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vuepress/TS%E6%8C%87%E5%8D%97/%E7%B1%BB%E5%9E%8B/#对象属性修饰" class="sidebar-link">对象属性修饰</a></li><li class="sidebar-sub-header"><a href="/vuepress/TS%E6%8C%87%E5%8D%97/%E7%B1%BB%E5%9E%8B/#type-和-interface" class="sidebar-link">type 和 interface</a></li><li class="sidebar-sub-header"><a href="/vuepress/TS%E6%8C%87%E5%8D%97/%E7%B1%BB%E5%9E%8B/#object、object-以及" class="sidebar-link">object、Object 以及 { }</a></li></ul></li><li class="sidebar-sub-header"><a href="/vuepress/TS%E6%8C%87%E5%8D%97/%E7%B1%BB%E5%9E%8B/#字面量类型" class="sidebar-link">字面量类型</a></li><li class="sidebar-sub-header"><a href="/vuepress/TS%E6%8C%87%E5%8D%97/%E7%B1%BB%E5%9E%8B/#枚举" class="sidebar-link">枚举</a></li><li class="sidebar-sub-header"><a href="/vuepress/TS%E6%8C%87%E5%8D%97/%E7%B1%BB%E5%9E%8B/#函数重载" class="sidebar-link">函数重载</a></li><li class="sidebar-sub-header"><a href="/vuepress/TS%E6%8C%87%E5%8D%97/%E7%B1%BB%E5%9E%8B/#class-修饰符" class="sidebar-link">class 修饰符</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vuepress/TS%E6%8C%87%E5%8D%97/%E7%B1%BB%E5%9E%8B/#静态成员" class="sidebar-link">静态成员</a></li></ul></li><li class="sidebar-sub-header"><a href="/vuepress/TS%E6%8C%87%E5%8D%97/%E7%B1%BB%E5%9E%8B/#内置类型-any-unkonwn-和-never" class="sidebar-link">内置类型 any,unkonwn 和 never</a></li><li class="sidebar-sub-header"><a href="/vuepress/TS%E6%8C%87%E5%8D%97/%E7%B1%BB%E5%9E%8B/#类型断言-警告编译器不准报错" class="sidebar-link">类型断言：警告编译器不准报错</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vuepress/TS%E6%8C%87%E5%8D%97/%E7%B1%BB%E5%9E%8B/#双重断言" class="sidebar-link">双重断言</a></li><li class="sidebar-sub-header"><a href="/vuepress/TS%E6%8C%87%E5%8D%97/%E7%B1%BB%E5%9E%8B/#非空断言" class="sidebar-link">非空断言</a></li></ul></li></ul></li><li><a href="/vuepress/TS%E6%8C%87%E5%8D%97/%E7%B1%BB%E5%9E%8B%E5%B7%A5%E5%85%B7/" class="sidebar-link">类型工具</a></li><li><a href="/vuepress/TS%E6%8C%87%E5%8D%97/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98/" class="sidebar-link">函数的协变与逆变</a></li><li><a href="/vuepress/TS%E6%8C%87%E5%8D%97/%E8%A3%85%E9%A5%B0%E5%99%A8/" class="sidebar-link">装饰器原理及使用</a></li><li><a href="/vuepress/TS%E6%8C%87%E5%8D%97/%E5%8F%8D%E5%B0%84%E5%85%83%E6%95%B0%E6%8D%AE/" class="sidebar-link">反射元数据</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/vuepress/心得/" class="sidebar-heading clickable"><span>心得体会</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="类型"><a href="#类型" class="header-anchor">#</a> 类型</h1> <h2 id="原始类型"><a href="#原始类型" class="header-anchor">#</a> 原始类型</h2> <ul><li>number</li> <li>string</li> <li>boolean</li> <li>null</li> <li>undefined</li> <li>symbol</li> <li>bigint</li> <li>void</li></ul> <p>其中，除了 <code>null</code> 与 <code>undefined</code> 以外，余下的类型基本上可以完全对应到 JavaScript 中的数据类型概念，因此这里我们只对 <code>null</code> 与 <code>undefined</code> 展开介绍。</p> <p><code>null</code> 和 <code>undefined</code> <strong>在 TS 里都是有实际意义的类型</strong> 和 JS 中不一样。</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">const</span> tmp1<span class="token operator">:</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> tmp2<span class="token operator">:</span> <span class="token keyword">undefined</span> <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
<span class="token comment">// 以下两个仅在关闭 strictNullChecks 时成立</span>
<span class="token keyword">const</span> tmp3<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> tmp4<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
</code></pre></div><p>void 类型
用于描述没有 <code>return</code> 的函数返回值。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">func3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>func1</code> 和 <code>func2</code> 的返回值类型都会被隐式推导为 <code>void</code> ，只有显式返回了 <code>undefined</code> 值的 <code>func3</code> 其返回值类型才被推导为了 <code>undefined。</code></p> <h2 id="数组的类型标注"><a href="#数组的类型标注" class="header-anchor">#</a> 数组的类型标注</h2> <p>在 TypeScript 中有两种方式来声明一个数组类型：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> arr1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> arr2<span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>有时候我们可以使用 **元组（Tuple）**来代替数组更加妥当。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> arr4<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;2&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;3&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr4<span class="token punctuation">[</span><span class="token number">599</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这时就会报错。</p> <p>在实际中我们又是会将元组中的元素打上标记，可以代替组装对象</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> arr7<span class="token operator">:</span> <span class="token punctuation">[</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> male<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;xiaowo&quot;</span><span class="token punctuation">,</span> <span class="token number">599</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>在解构的时候也会有警告</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> arr5<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">boolean</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;xiaowo&quot;</span><span class="token punctuation">,</span> <span class="token number">599</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 长度为 &quot;3&quot; 的元组类型 &quot;[string, number, boolean]&quot; 在索引 &quot;3&quot; 处没有元素。</span>
<span class="token keyword">const</span> <span class="token punctuation">[</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> male<span class="token punctuation">,</span> other<span class="token punctuation">]</span> <span class="token operator">=</span> arr5<span class="token punctuation">;</span>
</code></pre></div><p><strong>但使用元组确实能帮助我们进一步提升数组结构的严谨性，包括基于位置的类型标注、避免出现越界访问等等。</strong></p> <h2 id="对象的类型标注"><a href="#对象的类型标注" class="header-anchor">#</a> 对象的类型标注</h2> <p>在 ts 中我们用 <code>interface</code> 来描述对象类型。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">IDescription</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  male<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> obj1<span class="token operator">:</span> IDescription <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;linbudu&quot;</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token number">599</span><span class="token punctuation">,</span>
  male<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>这里的描述指的是：</p> <ul><li><p>每一个属性的值必须一一对应到接口的属性类型</p></li> <li><p>不能有多的属性，也不能有少的属性，包括直接在对象内部声明，或是 <code>obj1.other = 'xxx'</code> 这样属性访问赋值的形式</p></li></ul> <h3 id="对象属性修饰"><a href="#对象属性修饰" class="header-anchor">#</a> 对象属性修饰</h3> <ol><li>可选 - 用 ?</li> <li>只读 - 用 readonly</li></ol> <h3 id="type-和-interface"><a href="#type-和-interface" class="header-anchor">#</a> type 和 interface</h3> <p>虽然可以用 <code>type</code>（Type Alias，类型别名）来代替接口结构描述对象，</p> <p>但是更推荐的方式是， <code>interface</code> 用来描述对象、类的结构，</p> <p>而 <code>type</code> 类型别名用来将一个函数签名、一组联合类型、一个工具类型等等抽离成一个完整独立的类型。</p> <h3 id="object、object-以及"><a href="#object、object-以及" class="header-anchor">#</a> object、Object 以及 { }</h3> <p>Object , Number , String , Symbol , Boolean 是装箱类型</p> <p>{} 对象字面量类型，作为类型前面是一个合法的，<strong>但是内部属性无法定义的空对象，无法对这个变量进行任何赋值操作</strong></p> <p>⚠️ 在任何时候都不要，不要，不要使用 Object 以及类似的装箱类型。</p> <p>⚠️ 当你不确定某个变量的具体类型，但能确定它不是原始类型，可以使用 object。但我更推荐进一步区分，也就是使用 Record&lt;string, unknown&gt; 或 Record&lt;string, any&gt; 表示对象，unknown[] 或 any[] 表示数组，(...args: any[]) =&gt; any 表示函数这样。</p> <p>⚠️ 我们同样要避免使用{}。{}意味着任何非 null / undefined 的值，从这个层面上看，使用它和使用 any 一样恶劣。</p> <h2 id="字面量类型"><a href="#字面量类型" class="header-anchor">#</a> 字面量类型</h2> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Res</span> <span class="token punctuation">{</span>
  code<span class="token operator">:</span> <span class="token number">10000</span> <span class="token operator">|</span> <span class="token number">10001</span> <span class="token operator">|</span> <span class="token number">50000</span><span class="token punctuation">;</span>
  status<span class="token operator">:</span> <span class="token string">&quot;success&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;failure&quot;</span><span class="token punctuation">;</span>
  data<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面的 <code>status</code> 就是<strong>字符串字面量类型</strong>，除此还有<strong>数字字面量类型</strong>，<strong>布尔字面量类型</strong>和<strong>对象字面量类型</strong></p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> str<span class="token operator">:</span> <span class="token string">&quot;linbudu&quot;</span> <span class="token operator">=</span> <span class="token string">&quot;linbudu&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> num<span class="token operator">:</span> <span class="token number">599</span> <span class="token operator">=</span> <span class="token number">599</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> bool<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</code></pre></div><p>当对象类型中的属性全部是字面量类型的时候就是对象字面量类型。</p> <p>⚠️ 需要注意的是，无论是原始类型还是对象类型的字面量类型，它们的本质都是类型而不是值。它们在编译时同样会被擦除，同时也是被存储在内存中的类型空间而非值空间。</p> <h2 id="枚举"><a href="#枚举" class="header-anchor">#</a> 枚举</h2> <p>枚举在其他的语言中非常常见，在 JavaScript 中我们可以这样来模拟枚举。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">Home_Page_Url</span><span class="token operator">:</span> <span class="token string">&quot;url1&quot;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">Setting_Page_Url</span><span class="token operator">:</span> <span class="token string">&quot;url2&quot;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">Share_Page_Url</span><span class="token operator">:</span> <span class="token string">&quot;url3&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 或是这样：</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> PageUrl <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">Home_Page_Url</span><span class="token operator">:</span> <span class="token string">&quot;url1&quot;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">Setting_Page_Url</span><span class="token operator">:</span> <span class="token string">&quot;url2&quot;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">Share_Page_Url</span><span class="token operator">:</span> <span class="token string">&quot;url3&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>将上面的代码替换成枚举就变成</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">enum</span> PageUrl <span class="token punctuation">{</span>
  Home_Page_Url <span class="token operator">=</span> <span class="token string">&quot;url1&quot;</span><span class="token punctuation">,</span>
  Setting_Page_Url <span class="token operator">=</span> <span class="token string">&quot;url2&quot;</span><span class="token punctuation">,</span>
  Share_Page_Url <span class="token operator">=</span> <span class="token string">&quot;url3&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> home <span class="token operator">=</span> PageUrl<span class="token punctuation">.</span>Home_Page_Url<span class="token punctuation">;</span>
</code></pre></div><p>枚举和对象的重要差异在于，对象是单向映射的，我们只能从键映射到键值。而枚举是双向映射的，即你可以从枚举成员映射到枚举值，也可以从枚举值映射到枚举成员：</p> <p>⚠️ 只有数字枚举成员才能够进行这样的双向枚举，字符串枚举成员仍然只会进行单次映射</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">enum</span> Items <span class="token punctuation">{</span>
  Foo<span class="token punctuation">,</span>
  Bar<span class="token punctuation">,</span>
  Baz<span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> fooValue <span class="token operator">=</span> Items<span class="token punctuation">.</span>Foo<span class="token punctuation">;</span> <span class="token comment">// 0</span>
<span class="token keyword">const</span> fooKey <span class="token operator">=</span> Items<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// &quot;Foo&quot;</span>
</code></pre></div><h2 id="函数重载"><a href="#函数重载" class="header-anchor">#</a> 函数重载</h2> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span>foo<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> bar<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span>foo<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> bar<span class="token operator">?</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span>foo<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> bar<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>bar<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">String</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> foo <span class="token operator">*</span> <span class="token number">599</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> res1 <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">599</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// number</span>
<span class="token keyword">const</span> res2 <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">599</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// string</span>
<span class="token keyword">const</span> res3 <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">599</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// number</span>
</code></pre></div><p>实际上，TypeScript 中的重载更像是伪重载，<strong>它只有一个具体实现，其重载体现在方法调用的签名上而非具体实现上</strong>。而在如 C++ 等语言中，重载体现在多个名称一致但入参不同的函数实现上，这才是更广义上的函数重载。</p> <h2 id="class-修饰符"><a href="#class-修饰符" class="header-anchor">#</a> class 修饰符</h2> <p>访问性修饰符</p> <ul><li>public：此类成员在类、类的实例、子类中都能被访问。</li> <li>private：此类成员仅能在类的内部被访问。</li> <li>protected：此类成员仅能在类与子类中被访问，你可以将类和类的实例当成两种概念，即一旦实例化完毕（出厂零件），那就和类（工厂）没关系了，即不允许再访问受保护的成员。</li></ul> <p>操作修饰符</p> <ul><li>readonly：只读</li></ul> <h3 id="静态成员"><a href="#静态成员" class="header-anchor">#</a> 静态成员</h3> <ul><li>用 static 来标示</li> <li>不能用 this 来访问</li> <li>不被继承</li></ul> <p><strong>静态成员直接被挂载在函数体上，而实例成员挂载在原型上</strong></p> <p>静态成员不会被实例继承，它始终只属于当前定义的这个类（以及其子类）。</p> <p>而原型对象上的实例成员则会沿着原型链进行传递，也就是能够被继承。</p> <h2 id="内置类型-any-unkonwn-和-never"><a href="#内置类型-any-unkonwn-和-never" class="header-anchor">#</a> 内置类型 any,unkonwn 和 never</h2> <p>any - 不进行类型校验</p> <p>unknown - 未知类型，后续会利用断言来增加类型</p> <p>never - 空类型</p> <h2 id="类型断言-警告编译器不准报错"><a href="#类型断言-警告编译器不准报错" class="header-anchor">#</a> 类型断言：警告编译器不准报错</h2> <p>关键词 as, 也可以使用 <code>&lt;&gt;</code> 语法</p> <h3 id="双重断言"><a href="#双重断言" class="header-anchor">#</a> 双重断言</h3> <p>如果类型差异过大的话可以先断言成 unknown 再断言成想要的类型。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> str<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">&quot;linbudu&quot;</span><span class="token punctuation">;</span>

<span class="token punctuation">(</span>str <span class="token keyword">as</span> <span class="token builtin">unknown</span> <span class="token keyword">as</span> <span class="token punctuation">{</span> <span class="token function-variable function">handler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="非空断言"><a href="#非空断言" class="header-anchor">#</a> 非空断言</h3> <p>简写 <code>!</code> ，相当于可选链式操作符 <code>?.</code></p> <p>类型断言还有一种用法是作为代码提示的辅助工具，比如对于以下这个稍微复杂的接口：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">IStruct</span> <span class="token punctuation">{</span>
  foo<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  bar<span class="token operator">:</span> <span class="token punctuation">{</span>
    barPropA<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
    barPropB<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
    <span class="token function-variable function">barMethod</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
    baz<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token function-variable function">handler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>假设你想要基于这个结构随便实现一个对象，你可能会使用类型标注：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> obj<span class="token operator">:</span> IStruct <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>这个时候等待你的是一堆类型报错，你必须规规矩矩地实现整个接口结构才可以。但如果使用类型断言，我们可以在保留类型提示的前提下，不那么完整地实现这个结构：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// 这个例子是不会报错的</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token operator">&lt;</span>IStruct<span class="token operator">&gt;</span><span class="token punctuation">{</span>
  bar<span class="token operator">:</span> <span class="token punctuation">{</span>
    baz<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>而且还保存了提示。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/vuepress/assets/js/app.40312837.js" defer></script><script src="/vuepress/assets/js/2.cf1e524c.js" defer></script><script src="/vuepress/assets/js/37.e955d687.js" defer></script>
  </body>
</html>
